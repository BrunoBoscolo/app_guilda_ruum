<!DOCTYPE html>
{% load static %}
<html class="dark" lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Mapa do Reino</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&amp;family=Inter:wght@300;400;600&amp;family=MedievalSharp&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,typography,container-queries"></script>
<script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#8B1E1E",
              gold: "#D4AF37",
              ivory: "#F4F1EA",
              "background-dark": "#0F0C0C",
              "card-dark": "#1A1616",
            },
            fontFamily: {
              display: ["Cinzel", "serif"],
              medieval: ["MedievalSharp", "cursive"],
              sans: ["Inter", "sans-serif"],
            },
            boxShadow: {
                'epic': '0 10px 30px -5px rgba(0, 0, 0, 0.8), 0 4px 10px -5px rgba(139, 30, 30, 0.3)',
            }
          },
        },
      };
</script>
<style>
    body {
        overscroll-behavior: none;
        user-select: none;
    }
    #map-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        background: #0F0C0C;
    }
    #bottom-sheet {
        position: fixed;
        bottom: 80px; /* Above nav */
        left: 0;
        width: 100%;
        background: rgba(26, 22, 22, 0.95);
        backdrop-filter: blur(10px);
        border-top: 2px solid #D4AF37;
        padding: 20px;
        transform: translateY(150%);
        transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        z-index: 40;
        border-radius: 20px 20px 0 0;
        box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
    }
    #bottom-sheet.active {
        transform: translateY(0);
    }
    .loading-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #0F0C0C;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 50;
        color: #D4AF37;
        font-family: 'Cinzel', serif;
        transition: opacity 0.5s ease;
    }
</style>
</head>
<body class="bg-background-dark text-ivory h-screen w-screen overflow-hidden">

<div id="map-container"></div>

<div id="loading-overlay" class="loading-overlay">
    <div class="flex flex-col items-center gap-4">
        <span class="material-symbols-outlined text-4xl animate-spin">explore</span>
        <span>Carregando Mapa...</span>
    </div>
</div>

<header class="absolute top-0 left-0 w-full p-4 z-10 pointer-events-none">
    <h1 class="cinzel text-2xl font-black text-gold drop-shadow-lg text-center">Mapa do Reino</h1>
</header>

<div id="bottom-sheet">
    <div class="w-12 h-1 bg-white/20 rounded-full mx-auto mb-4"></div>
    <h2 id="sheet-title" class="cinzel text-xl font-bold text-gold mb-2">Local</h2>
    <p id="sheet-desc" class="medieval text-lg text-ivory/80 leading-relaxed">Descrição do local...</p>
</div>

<!-- Nav (Visual only mostly, maintains consistency) -->
<nav class="fixed bottom-0 left-0 right-0 bg-black/80 backdrop-blur-xl border-t border-white/10 px-6 py-4 flex justify-between items-center z-50">
    <a href="{% url 'sede' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">home</span>
        <span class="text-[9px] cinzel font-bold uppercase">Sede</span>
    </a>
    <a href="{% url 'missoes' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">history_edu</span>
        <span class="text-[9px] cinzel font-bold uppercase">Contratos</span>
    </a>
    <div class="relative -mt-12">
        <a href="#" class="w-14 h-14 bg-primary rounded-full flex items-center justify-center border-4 border-background-dark shadow-epic group transition-all hover:scale-105 active:scale-95 text-gold">
            <span class="material-symbols-outlined text-3xl">map</span>
        </a>
    </div>
    <a href="{% url 'bestiario' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">menu_book</span>
        <span class="text-[9px] cinzel font-bold uppercase">Bestiário</span>
    </a>
    <a href="{% url 'mestre' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">shield</span>
        <span class="text-[9px] cinzel font-bold uppercase">Mestre</span>
    </a>
</nav>

<!-- Three.js Import Map -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

{{ locations|json_script:"locations-data" }}

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { MapControls } from 'three/addons/controls/MapControls.js';

    // Constants
    const HEX_RADIUS = 5;
    const GRID_SIZE = 5; // Smaller grid for performance on mobile

    // Logic to determine texture URL (ImageField.url vs Static)
    let TEXTURE_URL = "{{ map_image_url }}";

    const STATIC_PREFIX = "{% get_static_prefix %}";
    const PINS_PATH = STATIC_PREFIX + "guilda_manager/pins/";

    const locations = JSON.parse(document.getElementById('locations-data').textContent);

    let fogUniforms = null;

    // Setup
    const container = document.getElementById('map-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0F0C0C); // Dark background
    scene.fog = new THREE.Fog(0x0F0C0C, 100, 500);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 45, 30);
    camera.lookAt(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new MapControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false; // Pan on ground plane
    controls.minDistance = 20;
    controls.maxDistance = 80;
    controls.maxPolarAngle = Math.PI / 2.5; // Don't let go below ground
    controls.enableRotate = false; // Keep fixed orientation as requested

    // Ensure one-finger/left-click is PAN
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.ROTATE
    }
    controls.touches = {
        ONE: THREE.TOUCH.PAN,
        TWO: THREE.TOUCH.DOLLY_ROTATE
    }

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
    scene.add(ambientLight);

    /*
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.3);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);
    */

    const dirLight = new THREE.DirectionalLight(0xD4AF37, 0.5); // Golden sunlight
    dirLight.position.set(20, 50, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Grid Group
    const gridGroup = new THREE.Group();
    scene.add(gridGroup);

    // Helpers (Pointy-Topped Hexagon Math)
    function hexToPixel(q, r) {
        // Pointy-Topped Math:
        // x = size * sqrt(3) * (q + r/2)
        // z = size * 3/2 * r
        const x = HEX_RADIUS * Math.sqrt(3) * (q + r/2);
        const z = HEX_RADIUS * 3/2 * r;
        return { x, z };
    }

    // Load Texture & Build Grid
    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin('anonymous');
    textureLoader.load(TEXTURE_URL, (texture) => {
        texture.colorSpace = THREE.SRGBColorSpace;

        // Calculate Average Colors for Fog (4x4 Grid)
        let fogColorMap = null;
        try {
            const image = texture.image;
            const canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0);

            const colorData = new Uint8Array(4 * 4 * 4); // 16 pixels, RGBA

            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    // Map UV bounds corresponding to this Fog Cell
                    // Fog UV: 0..1 covers 3x Map Size. Map is in center 1/3.
                    // Map UV u = 3 * fogU - 1
                    const u0 = Math.max(0, 3 * (x / 4) - 1);
                    const u1 = Math.min(1, 3 * ((x + 1) / 4) - 1);
                    const v0 = Math.max(0, 3 * (y / 4) - 1);
                    const v1 = Math.min(1, 3 * ((y + 1) / 4) - 1);

                    let r=50, g=56, b=64; // Default Dark Grey

                    if (u1 > u0 && v1 > v0) {
                        const px = Math.floor(u0 * image.width);
                        const py = Math.floor((1 - v1) * image.height); // Flip Y
                        const pw = Math.max(1, Math.floor((u1 - u0) * image.width));
                        const ph = Math.max(1, Math.floor((v1 - v0) * image.height));

                        if (px >= 0 && py >= 0 && px + pw <= image.width && py + ph <= image.height) {
                            const data = ctx.getImageData(px, py, pw, ph).data;
                            let sr=0, sg=0, sb=0, sc=0;
                            for(let i=0; i<data.length; i+=4) {
                                sr += data[i]; sg += data[i+1]; sb += data[i+2]; sc++;
                            }
                            if (sc > 0) {
                                r = sr / sc; g = sg / sc; b = sb / sc;
                            }
                        }
                    }
                    const index = (y * 4 + x) * 4;
                    colorData[index] = r;
                    colorData[index+1] = g;
                    colorData[index+2] = b;
                    colorData[index+3] = 255;
                }
            }
            fogColorMap = new THREE.DataTexture(colorData, 4, 4, THREE.RGBAFormat);
            fogColorMap.minFilter = THREE.LinearFilter;
            fogColorMap.magFilter = THREE.LinearFilter;
            fogColorMap.needsUpdate = true;
        } catch(e) {
            console.error("Error generating fog colors", e);
            // Fallback texture
            const white = new Uint8Array(4*4*4).fill(50);
            fogColorMap = new THREE.DataTexture(white, 4, 4, THREE.RGBAFormat);
            fogColorMap.needsUpdate = true;
        }

        // Calculate Grid Bounds
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        const hexData = [];

        for (let q = -GRID_SIZE; q <= GRID_SIZE; q++) {
            let r1 = Math.max(-GRID_SIZE, -q - GRID_SIZE);
            let r2 = Math.min(GRID_SIZE, -q + GRID_SIZE);
            for (let r = r1; r <= r2; r++) {
                const pos = hexToPixel(q, r);
                hexData.push({q, r, x: pos.x, z: pos.z});
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            }
        }

        // Add margin
        const margin = HEX_RADIUS * 2;
        minX -= margin; maxX += margin;
        minZ -= margin; maxZ += margin;
        const width = maxX - minX;
        const height = maxZ - minZ;

        // Create Background Plane to prevent gaps
        const planeGeo = new THREE.PlaneGeometry(width, height);
        const planeMat = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.8,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(minX + width/2, -0.6, minZ + height/2);
        gridGroup.add(plane);

        // Custom Fog Logic
        // Use a much larger plane (3x) to cover the whole board and avoid visible edges
        const fogWidth = width * 3.0;
        const fogHeight = height * 3.0;
        const fogGeo = new THREE.PlaneGeometry(fogWidth, fogHeight, 128, 128);

        fogUniforms = {
            uFogColorMap: { value: fogColorMap },
            uTime: { value: 0.0 }
        };

        const fogMat = new THREE.ShaderMaterial({
            uniforms: fogUniforms,
            vertexShader: `
                varying vec2 vUv;
                varying float vWave;
                uniform float uTime;

                void main() {
                    vUv = uv;
                    vec3 pos = position;

                    // Wave Animation
                    // Sine wave based on position and time
                    float wave = sin(uv.x * 15.0 + uTime) * cos(uv.y * 12.0 + uTime * 0.7) * 4.0;
                    pos.z += wave;
                    vWave = wave;

                    // Waterfall Drop Effect at Far Edges
                    vec2 center = vec2(0.5);
                    vec2 d = abs(uv - center);
                    float boxDist = max(d.x, d.y);

                    // Start dropping at 0.45 (near edge of the 3x plane)
                    if (boxDist > 0.45) {
                        float drop = (boxDist - 0.45) / 0.05;
                        pos.z -= drop * drop * 50.0;
                    }

                    // Extra drop for North Edge to hide parallax border
                    if (uv.y > 0.62) {
                        float northDrop = (uv.y - 0.62);
                        pos.z -= northDrop * northDrop * 2000.0;
                    }

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D uFogColorMap;
                uniform float uTime;
                varying vec2 vUv;
                varying float vWave;

                // Simplex 2D noise
                vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

                float snoise(vec2 v){
                  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                           -0.577350269189626, 0.024390243902439);
                  vec2 i  = floor(v + dot(v, C.yy) );
                  vec2 x0 = v -   i + dot(i, C.xx);
                  vec2 i1;
                  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                  vec4 x12 = x0.xyxy + C.xxzz;
                  x12.xy -= i1;
                  i = mod(i, 289.0);
                  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                  + i.x + vec3(0.0, i1.x, 1.0 ));
                  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                    dot(x12.zw,x12.zw)), 0.0);
                  m = m*m ;
                  m = m*m ;
                  vec3 x = 2.0 * fract(p * C.www) - 1.0;
                  vec3 h = abs(x) - 0.5;
                  vec3 ox = floor(x + 0.5);
                  vec3 a0 = x - ox;
                  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                  vec3 g;
                  g.x  = a0.x  * x0.x  + h.x  * x0.y;
                  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                  return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 center = vec2(0.5, 0.5);
                    vec2 distVec = abs(vUv - center);
                    float dist = max(distVec.x, distVec.y);

                    float n = snoise(vUv * 8.0 + vec2(uTime * 0.1, uTime * 0.05));

                    // Fog Color Logic:
                    // Sample from 4x4 grid color map
                    vec3 fogColor = texture2D(uFogColorMap, vUv).rgb;
                    fogColor += vWave * 0.02; // Subtle highlights

                    // Fog Alpha:
                    // Only start fogging near the edges, keeping the center clear.
                    // Adjusted to reach full opacity before the map edge (approx 0.166 dist)
                    float baseAlpha = smoothstep(0.10, 0.15, dist + n * 0.02);

                    // Static fog layer to ensure border coverage regardless of noise
                    float staticAlpha = smoothstep(0.14, 0.16, dist);

                    // Extra opacity boost for North side to cover parallax gap
                    float farFog = smoothstep(0.63, 0.66, vUv.y);

                    float fogAlpha = max(baseAlpha, max(staticAlpha, farFog));

                    // Fade to black at very edge for smooth blending with void background
                    vec3 finalFog = mix(fogColor, vec3(0.0), smoothstep(0.16, 0.22, dist));

                    gl_FragColor = vec4(finalFog, fogAlpha);
                }
            `,
            transparent: true,
            depthWrite: false,
        });

        const fogPlane = new THREE.Mesh(fogGeo, fogMat);
        fogPlane.rotation.x = -Math.PI / 2;
        // Raise fog plane to avoid clipping (wave amplitude is 4.0, so 6.0 > 4.0 safely)
        fogPlane.position.set(minX + width/2, 6.0, minZ + height/2);
        fogPlane.raycast = function() {}; // Disable clicks on fog
        gridGroup.add(fogPlane);

        // Create Pointy-Topped Hex Geometry
        // CylinderGeometry(radius, radius, height, segments) creates a prism.
        // By default vertices start at 0 degrees (Pointy East), edges are horizontal (Flat-Topped).
        // Use a slightly larger radius (1.2) to ensure overlap and eliminate gaps
        const geometry = new THREE.CylinderGeometry(HEX_RADIUS, HEX_RADIUS, 1, 6);
        //geometry.rotateY(Math.PI / 6); // Rotate vertices to align for Pointy-Topped

        const material = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.8,
            metalness: 0.1,
            transparent: false,
            side: THREE.DoubleSide
        });

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 15);
        const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });

        

        hexData.forEach(d => {
            const mesh = new THREE.Mesh(geometry.clone(), material.clone());

            mesh.position.set(d.x, 0, d.z);
            mesh.userData = { q: d.q, r: d.r, originalY: 0 };

            const outline = new THREE.LineSegments(edgesGeometry, edgesMaterial);

            outline.position.y = 0.005;
            outline.scale.set(1.005, 1, 1.005);

            mesh.add(outline);

            // UV Mapping
            const uvs = mesh.geometry.attributes.uv;
            const positions = mesh.geometry.attributes.position;

            for (let i = 0; i < uvs.count; i++) {
                const lx = positions.getX(i);
                const lz = positions.getZ(i);

                const wx = d.x + lx;
                const wz = d.z + lz;

                // Normalize to 0..1
                const u = (wx - minX) / width;
                const v = 1 - (wz - minZ) / height; // Flip V

                uvs.setXY(i, u, v);
            }
            mesh.geometry.attributes.uv.needsUpdate = true;
            gridGroup.add(mesh);
        });

        // Hide Loading
        const overlay = document.getElementById('loading-overlay');
        overlay.style.opacity = 0;
        setTimeout(() => overlay.style.display = 'none', 500);

        // Load Pins
        const gltfLoader = new GLTFLoader();
        locations.forEach(loc => {
            const hex = gridGroup.children.find(c => c.userData.q === loc.q && c.userData.r === loc.r);
            if (hex) {
                hex.userData.hasPin = true;
                hex.userData.info = loc;

                const path = PINS_PATH + loc.model;
                gltfLoader.load(path, (gltf) => {
                    const model = gltf.scene;
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = (HEX_RADIUS * 0.8) / maxDim;

                    model.scale.set(scale, scale, scale);
                    model.position.set(0, 0.5, 0); // Sit on top
                    // Pins need to account for parent rotation? No, parent is Mesh.
                    // But if parent Geometry is rotated, children are relative to Mesh transform.
                    // Wait. geometry.rotateY() modifies vertices. It does NOT modify mesh.rotation.
                    // So children added to mesh are unaffected by geometry rotation.
                    // But if we want pin facing "front", that depends on model.
                    hex.add(model);
                });
            }
        });

    }, undefined, (err) => {
        console.error("Texture Load Error", err);
    });

    // Interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedHex = null;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    function onPointerDown(event) {
        isDragging = false;
        if (event.changedTouches) {
            startX = event.changedTouches[0].clientX;
            startY = event.changedTouches[0].clientY;
        } else {
            startX = event.clientX;
            startY = event.clientY;
        }
    }

    function onPointerMove(event) {
        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        const dist = Math.sqrt(Math.pow(clientX - startX, 2) + Math.pow(clientY - startY, 2));
        if (dist > 5) { // 5px threshold
            isDragging = true;
        }
    }

    function onPointerUp(event) {
        if (isDragging) return; // Ignore drags

        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gridGroup.children, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            // Find parent hex
            while(target.parent && target.parent !== gridGroup) {
                target = target.parent;
            }
            if (target.parent !== gridGroup) return;

            // Ignore background plane or other non-hex objects
            if (target.userData.q === undefined) return;

            if (selectedHex && selectedHex !== target) {
                 animateHex(selectedHex, 0);
            }

            selectedHex = target;
            animateHex(selectedHex, 2);

            const info = selectedHex.userData.info;
            const title = info ? info.title : "Terreno Baldio";
            const desc = info ? info.description : "Apenas hexágonos e poeira...";

            document.getElementById('sheet-title').innerText = title;
            document.getElementById('sheet-desc').innerText = desc;
            document.getElementById('bottom-sheet').classList.add('active');

        } else {
            if (selectedHex) {
                animateHex(selectedHex, 0);
                selectedHex = null;
                document.getElementById('bottom-sheet').classList.remove('active');
            }
        }
    }

    function animateHex(hex, targetY) {
        const startY = hex.position.y;
        const startTime = Date.now();
        const duration = 300;

        function loop() {
            const now = Date.now();
            const p = Math.min((now - startTime) / duration, 1);
            const ease = 1 - Math.pow(1 - p, 3);
            hex.position.y = startY + (targetY - startY) * ease;
            if (p < 1) requestAnimationFrame(loop);
        }
        loop();
    }

    window.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate() {
        requestAnimationFrame(animate);

        if (fogUniforms) {
            fogUniforms.uTime.value += 0.01;
        }

        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>

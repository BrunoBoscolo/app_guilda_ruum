<!DOCTYPE html>
{% load static %}
<html class="dark" lang="pt-br">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Mapa do Reino</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&amp;family=Inter:wght@300;400;600&amp;family=MedievalSharp&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,typography,container-queries"></script>
<script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#8B1E1E",
              gold: "#D4AF37",
              ivory: "#F4F1EA",
              "background-dark": "#0F0C0C",
              "card-dark": "#1A1616",
            },
            fontFamily: {
              display: ["Cinzel", "serif"],
              medieval: ["MedievalSharp", "cursive"],
              sans: ["Inter", "sans-serif"],
            },
            boxShadow: {
                'epic': '0 10px 30px -5px rgba(0, 0, 0, 0.8), 0 4px 10px -5px rgba(139, 30, 30, 0.3)',
            }
          },
        },
      };
</script>
<style>
    body {
        overscroll-behavior: none;
        user-select: none;
    }
    #map-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        background: #0F0C0C;
    }
    #bottom-sheet {
        position: fixed;
        bottom: 80px; /* Above nav */
        left: 0;
        width: 100%;
        background: rgba(26, 22, 22, 0.95);
        backdrop-filter: blur(10px);
        border-top: 2px solid #D4AF37;
        padding: 20px;
        transform: translateY(150%);
        transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        z-index: 40;
        border-radius: 20px 20px 0 0;
        box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
    }
    #bottom-sheet.active {
        transform: translateY(0);
    }
    .loading-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #0F0C0C;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 50;
        color: #D4AF37;
        font-family: 'Cinzel', serif;
        transition: opacity 0.5s ease;
    }
</style>
</head>
<body class="bg-background-dark text-ivory h-screen w-screen overflow-hidden">

<div id="map-container"></div>

<div id="loading-overlay" class="loading-overlay">
    <div class="flex flex-col items-center gap-4">
        <span class="material-symbols-outlined text-4xl animate-spin">explore</span>
        <span>Carregando Mapa...</span>
    </div>
</div>

<header class="absolute top-0 left-0 w-full p-4 z-10 pointer-events-none">
    <h1 class="cinzel text-2xl font-black text-gold drop-shadow-lg text-center">Mapa do Reino</h1>
</header>

<div id="bottom-sheet">
    <div class="w-12 h-1 bg-white/20 rounded-full mx-auto mb-4"></div>
    <h2 id="sheet-title" class="cinzel text-xl font-bold text-gold mb-2">Local</h2>
    <p id="sheet-desc" class="medieval text-lg text-ivory/80 leading-relaxed">Descrição do local...</p>
</div>

<!-- Nav (Visual only mostly, maintains consistency) -->
<nav class="fixed bottom-0 left-0 right-0 bg-black/80 backdrop-blur-xl border-t border-white/10 px-6 py-4 flex justify-between items-center z-50">
    <a href="{% url 'sede' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">home</span>
        <span class="text-[9px] cinzel font-bold uppercase">Sede</span>
    </a>
    <a href="{% url 'missoes' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">history_edu</span>
        <span class="text-[9px] cinzel font-bold uppercase">Contratos</span>
    </a>
    <div class="relative -mt-12">
        <a href="#" class="w-14 h-14 bg-primary rounded-full flex items-center justify-center border-4 border-background-dark shadow-epic group transition-all hover:scale-105 active:scale-95 text-gold">
            <span class="material-symbols-outlined text-3xl">map</span>
        </a>
    </div>
    <a href="{% url 'bestiario' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">menu_book</span>
        <span class="text-[9px] cinzel font-bold uppercase">Bestiário</span>
    </a>
    <a href="{% url 'mestre' %}" class="flex flex-col items-center gap-1 group text-slate-500 hover:text-gold transition-colors">
        <span class="material-symbols-outlined">shield</span>
        <span class="text-[9px] cinzel font-bold uppercase">Mestre</span>
    </a>
</nav>

<!-- Three.js Import Map -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

{{ locations|json_script:"locations-data" }}

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { MapControls } from 'three/addons/controls/MapControls.js';

    // Constants
    const HEX_RADIUS = 5;
    const GRID_SIZE = 5; // Smaller grid for performance on mobile

    // Logic to determine texture URL (ImageField.url vs Static)
    let TEXTURE_URL = "{{ map_image_url }}";

    const STATIC_PREFIX = "{% get_static_prefix %}";
    const PINS_PATH = STATIC_PREFIX + "guilda_manager/pins/";

    const locations = JSON.parse(document.getElementById('locations-data').textContent);

    // Setup
    const container = document.getElementById('map-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0F0C0C); // Dark background
    scene.fog = new THREE.Fog(0x0F0C0C, 20, 150);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 45, 30);
    camera.lookAt(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new MapControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false; // Pan on ground plane
    controls.minDistance = 20;
    controls.maxDistance = 80;
    controls.maxPolarAngle = Math.PI / 2.5; // Don't let go below ground
    controls.enableRotate = false; // Keep fixed orientation as requested

    // Ensure one-finger/left-click is PAN
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.ROTATE
    }
    controls.touches = {
        ONE: THREE.TOUCH.PAN,
        TWO: THREE.TOUCH.DOLLY_ROTATE
    }

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xD4AF37, 1.2); // Golden sunlight
    dirLight.position.set(20, 50, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    scene.add(dirLight);

    // Grid Group
    const gridGroup = new THREE.Group();
    scene.add(gridGroup);

    // Helpers (Pointy-Topped Hexagon Math)
    function hexToPixel(q, r) {
        // Pointy-Topped Math:
        // x = size * sqrt(3) * (q + r/2)
        // z = size * 3/2 * r
        const x = HEX_RADIUS * Math.sqrt(3) * (q + r/2);
        const z = HEX_RADIUS * 3/2 * r;
        return { x, z };
    }

    // Load Texture & Build Grid
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(TEXTURE_URL, (texture) => {
        texture.colorSpace = THREE.SRGBColorSpace;

        // Calculate Grid Bounds
        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        const hexData = [];

        for (let q = -GRID_SIZE; q <= GRID_SIZE; q++) {
            let r1 = Math.max(-GRID_SIZE, -q - GRID_SIZE);
            let r2 = Math.min(GRID_SIZE, -q + GRID_SIZE);
            for (let r = r1; r <= r2; r++) {
                const pos = hexToPixel(q, r);
                hexData.push({q, r, x: pos.x, z: pos.z});
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minZ = Math.min(minZ, pos.z);
                maxZ = Math.max(maxZ, pos.z);
            }
        }

        // Add margin
        const margin = HEX_RADIUS * 2;
        minX -= margin; maxX += margin;
        minZ -= margin; maxZ += margin;
        const width = maxX - minX;
        const height = maxZ - minZ;

        // Create Background Plane to prevent gaps
        const planeGeo = new THREE.PlaneGeometry(width, height);
        const planeMat = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.8,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(minX + width/2, -0.6, minZ + height/2);
        gridGroup.add(plane);

        // Create Pointy-Topped Hex Geometry
        // CylinderGeometry(radius, radius, height, segments) creates a prism.
        // By default vertices start at 0 degrees (Pointy East), edges are horizontal (Flat-Topped).
        // Use a slightly larger radius (1.2) to ensure overlap and eliminate gaps
        const geometry = new THREE.CylinderGeometry(HEX_RADIUS, HEX_RADIUS, 1, 6);
        //geometry.rotateY(Math.PI / 6); // Rotate vertices to align for Pointy-Topped

        const material = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.8,
            metalness: 0.1,
            transparent: false,
            side: THREE.DoubleSide
        });

        const edgesGeometry = new THREE.EdgesGeometry(geometry, 15);
        const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });

        

        hexData.forEach(d => {
            const mesh = new THREE.Mesh(geometry.clone(), material.clone());

            mesh.position.set(d.x, 0, d.z);
            mesh.userData = { q: d.q, r: d.r, originalY: 0 };

            const outline = new THREE.LineSegments(edgesGeometry, edgesMaterial);

            outline.position.y = 0.005;
            outline.scale.set(1.005, 1, 1.005);

            mesh.add(outline);

            // UV Mapping
            const uvs = mesh.geometry.attributes.uv;
            const positions = mesh.geometry.attributes.position;

            for (let i = 0; i < uvs.count; i++) {
                const lx = positions.getX(i);
                const lz = positions.getZ(i);

                const wx = d.x + lx;
                const wz = d.z + lz;

                // Normalize to 0..1
                const u = (wx - minX) / width;
                const v = 1 - (wz - minZ) / height; // Flip V

                uvs.setXY(i, u, v);
            }
            mesh.geometry.attributes.uv.needsUpdate = true;
            gridGroup.add(mesh);
        });

        // Hide Loading
        const overlay = document.getElementById('loading-overlay');
        overlay.style.opacity = 0;
        setTimeout(() => overlay.style.display = 'none', 500);

        // Load Pins
        const gltfLoader = new GLTFLoader();
        locations.forEach(loc => {
            const hex = gridGroup.children.find(c => c.userData.q === loc.q && c.userData.r === loc.r);
            if (hex) {
                hex.userData.hasPin = true;
                hex.userData.info = loc;

                const path = PINS_PATH + loc.model;
                gltfLoader.load(path, (gltf) => {
                    const model = gltf.scene;
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = (HEX_RADIUS * 0.8) / maxDim;

                    model.scale.set(scale, scale, scale);
                    model.position.set(0, 0.5, 0); // Sit on top
                    // Pins need to account for parent rotation? No, parent is Mesh.
                    // But if parent Geometry is rotated, children are relative to Mesh transform.
                    // Wait. geometry.rotateY() modifies vertices. It does NOT modify mesh.rotation.
                    // So children added to mesh are unaffected by geometry rotation.
                    // But if we want pin facing "front", that depends on model.
                    hex.add(model);
                });
            }
        });

    }, undefined, (err) => {
        console.error("Texture Load Error", err);
    });

    // Interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedHex = null;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    function onPointerDown(event) {
        isDragging = false;
        if (event.changedTouches) {
            startX = event.changedTouches[0].clientX;
            startY = event.changedTouches[0].clientY;
        } else {
            startX = event.clientX;
            startY = event.clientY;
        }
    }

    function onPointerMove(event) {
        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        const dist = Math.sqrt(Math.pow(clientX - startX, 2) + Math.pow(clientY - startY, 2));
        if (dist > 5) { // 5px threshold
            isDragging = true;
        }
    }

    function onPointerUp(event) {
        if (isDragging) return; // Ignore drags

        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(gridGroup.children, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            // Find parent hex
            while(target.parent && target.parent !== gridGroup) {
                target = target.parent;
            }
            if (target.parent !== gridGroup) return;

            // Ignore background plane or other non-hex objects
            if (target.userData.q === undefined) return;

            if (selectedHex && selectedHex !== target) {
                 animateHex(selectedHex, 0);
            }

            selectedHex = target;
            animateHex(selectedHex, 2);

            const info = selectedHex.userData.info;
            const title = info ? info.title : "Terreno Baldio";
            const desc = info ? info.description : "Apenas hexágonos e poeira...";

            document.getElementById('sheet-title').innerText = title;
            document.getElementById('sheet-desc').innerText = desc;
            document.getElementById('bottom-sheet').classList.add('active');

        } else {
            if (selectedHex) {
                animateHex(selectedHex, 0);
                selectedHex = null;
                document.getElementById('bottom-sheet').classList.remove('active');
            }
        }
    }

    function animateHex(hex, targetY) {
        const startY = hex.position.y;
        const startTime = Date.now();
        const duration = 300;

        function loop() {
            const now = Date.now();
            const p = Math.min((now - startTime) / duration, 1);
            const ease = 1 - Math.pow(1 - p, 3);
            hex.position.y = startY + (targetY - startY) * ease;
            if (p < 1) requestAnimationFrame(loop);
        }
        loop();
    }

    window.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Animate
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

</script>
</body>
</html>
